# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n8EDensiDOd0aICUB8DTcJy7_0UyIiAi
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt



def DiluteBinary(img, ele):
    x,y = img.shape[:2]
    ex, ey = ele.shape[:2]
    img2 = do_zero_padding_1(img, ele)
    ex_hf = (ex//2 )
    ey_hf = (ey//2 )
    for c_e in range (ey):
        for r_e in range (ex):
            if( ele[r_e][c_e]==1):
                #Shift the image by r_e/2 and c_e/2 + factor
                for c in range(ey, y + ey):
                    for r in range(ex, x + ex):
                        img2[r + (  r_e - ex_hf )][c + (c_e - ey_hf)]= (img[r-ex][c-ey]) or img2[r + (  r_e - ex_hf )][c + (c_e - ey_hf)]
    img3 = inverse_zero_padding_1(img2, ele)
    return img3.astype(np.uint8)

def ErodeBinary(img, ele):
    x,y = img.shape[:2]
    ex, ey = ele.shape[:2]
    img2 = do_zero_padding_1(img, ele)
    img4 = do_zero_padding_1(img, ele)
    ex_hf = (ex // 2)
    ey_hf = (ey // 2)
    #Make a new image with center image
    for c in range(ey, y + ey):
        for r in range(ex, x + ex):
            img2[r][c] = img[r-ex][c-ey]
    x1, y1 = img2.shape[:2]
    #Move from top to down for the big image
    for c in range(y1-ey):
        for r in range(x1-ex):
            temp=0
            #compare the image with the mask
            for c_e in range(ey):
                for r_e in range(ex):
                    if(255*ele[r_e][c_e] == img2[r+r_e][c+c_e]):
                        temp = temp+1
            if(temp == ex*ey):
                img4[r+ex_hf][c+ey_hf]= 255
                #print("hi")
            else:
                img4[r+ex_hf][c+ey_hf]=0
            temp = 0
    # Do inverse padding of img4
    img3 = inverse_zero_padding_1(img4, ele)
    return img3.astype(np.uint8)


def Opening(img, ele):
    img2 = ErodeBinary(img, ele)
    img3 = DiluteBinary(img2, ele)
    return img3

# img dot ele
def Closing(img, ele):
    img2 = DiluteBinary(img, ele)
    img3 = ErodeBinary(img2, ele)
    return img3

#Zero Padding
def do_zero_padding_1(img, ele):
    x, y = img.shape[:2]
    x1, y1 = ele.shape[:2]
    img2 = np.array([[0] * (y+y1+y1)] * (x+x1+x1))
    for c in range(y1,y):
        for r in range(x1,x):
            img2[r][c]= img[r-x1][c-y1]
    return img2

# Removal of Zero Padding
def inverse_zero_padding_1(img, ele):
    x, y = img.shape[:2]
    x1, y1 = ele.shape[:2]

    img2 = np.array([[0] * (y-y1-y1)] * (x-x1-x1))
    for c in range(y-y1-y1):
        for r in range(x-x1-x1):
            img2[r][c]= img[r+x1][c+y1]
    return img2

#############################____MAIN PROGRAM____#############################
ele_1x2 = np.array([[1,1]])
ele_3x3_1 = np.array([[1,1,1],[1,1,1],[1,1,1]])
ele_3x3_2 = np.array([[0,1,0],[1,1,1],[0,1,0]])
ele_9x9= np.array([[1,1,1]*3,[1,1,1]*3,[1,1,1]*3]*3)
ele_15x15= np.array([[1,1,1]*5,[1,1,1]*5,[1,1,1]*5]*5)

el = ele_3x3_1

img= cv2.imread("ricegrains_mono.bmp",0)
img1 =DiluteBinary(img, el)
img2= ErodeBinary(img, el)
img3= Opening(img, el)
img4 = Closing(img, el)

plt.suptitle("Morphological Operations ")
plt.subplot(231), plt.imshow(img, cmap = 'gray'), plt.title("Original")
plt.subplot(232), plt.imshow(img1, cmap = 'gray'), plt.title("Diluted")
plt.subplot(233), plt.imshow(img2, cmap = 'gray'), plt.title("Eroded")
plt.subplot(223), plt.imshow(img3, cmap = 'gray'), plt.title("Opening")
plt.subplot(224), plt.imshow(img4, cmap = 'gray'), plt.title("Closing")

plt.show()

img