# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n8EDensiDOd0aICUB8DTcJy7_0UyIiAi
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

def convolve_2d(img,kernel):
    h= len(img)
    w= len(img[0])
    #img= np.array(img)
    img_new = np.zeros((h,w,1))
    for i in range(1,h-1):
        for j in range(1,w-1):
            temp  = 0
            for k in range(-1,2):
                for l in range(-1,2):
                    temp = temp + kernel[1+k][1+l] * img[i+k][j+l]
            img_new[i][j] =(temp)
    #print(img_new)
    return img_new
    
def mean_filter(img):
    flt = (np.array([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]))

    return convolve_2d(img,flt/9)

def median_filter(img):
    h = len(img)
    w = len(img[0])
    img_new = np.zeros((h,w,1), dtype = "uint8")
    for i in range(1,h-1):
        for j in range(1,w-1):
            temp  = []
            for k in range(-1,2):
                for l in range(-1,2):
                    temp.append(img[i+k][j+l])
            temp.sort()  
            img_new[i][j] = temp[5]
    return img_new

def prewitt_filter(img):
    flt = (np.array([[-1,0,1],[-1,0,1],[-1,0,1]]))
    return convolve_2d(img,flt)

def LOG_filter(img):
    flt = (np.array([[0,0.1,0],[-0.1,-0.3,-0.1],[0,-0.1,0]]))
    return convolve_2d(img,flt)

def laplacian_filter(img):
    flt = (np.array([[1,1,1],[1,-8,1],[1,1,1]]))
    return convolve_2d(img,flt)

def sobel_hor_filter(img):
    flt = (np.array([[-1,-2,-1],[0,0,0],[1,2,1]]))
    return convolve_2d(img,flt)

def sobel_ver_filter(img):
    flt = (np.array([[-1,0,1],[-2,0,2],[-1,0,1]]))
    return convolve_2d(img,flt)

def sobel_dia1_filter(img):
    flt = (np.array([[0,1,2],[-1,0,1],[-2,1,0]]))
    return convolve_2d(img,flt)

def sobel_dia2_filter(img):
    flt = (np.array([[-1,0,1],[-2,-1,0],[0,1,2]]))
    return convolve_2d(img,flt)

def gaussian_filter(img):
    flt = (np.array([[368,606,368],[606,1000,606],[368,606,368]])/6283)
    return convolve_2d(img,flt)

def divide_image(img1,img2):
    temp = img1
    for i in range(len(img1[0])):
        for j in range(len(img1)):
            temp[i][j] = img1[i][j] / img2[i][j]
    return temp

def gaussian_unblur(img):
    op_img = img
    for k in range(0,40):
        a = gaussian_filter(op_img)
        b = divide_image(img,a)        
        c = gaussian_filter(b)
        op_img = op_img * c
    return op_img

## returns ideal low pass filter
def ilpf(img,d):
    h,w = img.shape[:2]
    h1 = math.floor(h/2)
    w1 = math.floor(w/2)
    temp = np.array([[0]*w]*h)
    for i in range(-d,d):
        for j in range(-d,d):
            if((i*i)+(j*j)<=(d*d)):
                temp[h1+i][w1+j] = 1
    return temp

## returns ideal high pass filter
def ihpf(img,d):
    h,w = img.shape
    h1 = math.floor(h / 2)
    w1 = math.floor(w / 2)
    temp = np.array([[1]*w]*h)
    for i in range(-d,d):
        for j in range(-d,d):
            if ((i * i) + (j * j) <= (d * d)):
                temp[h1 + i][w1 + j] = 0

    return temp


## returns ideal low pass filter
def iflpf(img,d):
    h,w = img.shape[:2]
    h1 = math.floor(h/2)
    w1 = math.floor(w/2)
    temp = np.array([[0]*w]*h)
    for i in range(-d,d):
        for j in range(-d,d):
            if((i*i)+(j*j)<=(d*d)):
                temp[h1+i][w1+j] = 1
    return temp

## returns ideal high pass filter
def ifhpf(img,d):
    h,w = img.shape
    h1 = math.floor(h / 2)
    w1 = math.floor(w / 2)
    temp = np.array([[1]*w]*h)
    for i in range(-d,d):
        for j in range(-d,d):
            if ((i * i) + (j * j) <= (d * d)):
                temp[h1 + i][w1 + j] = 0

    return temp



## returns a gaussian low pass filter. here 'd' is sigma which is the cut off frequency
def gaussian_lpf(img,d):
    h,w = img.shape
    temp = np.array([[0.0]*w]*h)
    h1 = h//2
    w1 = w//2
    for i in range(-h1,h1):
        for j in range(-w1,w1):
            factor = (i**2 + j**2) /(2*(d**2))
            factor2 = 2*3.14*(d*d)
            temp[(h1)+i][(w1)+j] = (math.exp(-factor))
    return temp

## returns gaussian high pass filter
def gaussian_hpf(img,d):
    h,w = img.shape
    temp = np.array([[1.]*w]*h)
    return (temp - gaussian_lpf(img,d))

## returns butterworth low pass filter. 'n' is the order and 'd' is the cut off frequency
def butterworth_lpf(img,n,d):
    h,w = img.shape
    h1 = math.floor(h / 2)
    w1 = math.floor(w / 2)
    temp = np.float32([[0.0]*w]*h)
    for i in range(-h1,h1):
        for j in range(-w1,w1):
            if (d==0):
                temp[h1 + i][w1 + j]=0
            else:
                ratio = ((i**2 + j**2) / (d**2))**n
                temp[h1+i][w1+j] = 1 / (1 + ratio)


    return temp

## returns butterworth high pass filter. 'n' is the order and 'd' is the cut off frequency
def butterworth_hpf(img,n,d):
    h,w = img.shape
    temp = np.array([[1.0]*w]*h)
    h1 = math.floor(h / 2)
    w1 = math.floor(w / 2)
    for i in range(-h1,h1):
        for j in range(-w1,w1):
            if ((i**2 + j**2 )==0):
                temp[h1 + i][w1 + j]=0
            else:
                ratio = (d**2 / (i**2 + j**2 ))**n
                temp[h1+i][w1+j] = 1 / (1 + ratio)
    return temp

def idft_image(img_fft):                ## takes fft of an image as an input and returns 
    op_img_1 = np.fft.ifft2(img_fft)  ## idft of image
    op_img_2 = np.fft.ifft2(img_fft)
    op_img_3 = np.fft.ifft2(img_fft)
    #j = math.sqrt(1)
    for i in range(len(img_fft)):
        for k in range(len(img_fft[0])):
            op_img_1[i][k] = op_img_1[i][k].real
            x= op_img_1[i][k]
            #op_img_2[i][k]= op_img_2[i][k].imag
            #y= op_img_2[i][k]
            op_img_3[i][k]= np.absolute(x)
    op_img = np.abs(op_img_3)
    return op_img

img